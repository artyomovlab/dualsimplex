# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Get cosine similarity between columns
#'
#' @param a input vector a.
#' @param b input vector b.
#' @return double value of cosine distance
cosine_similarity <- function(a, b) {
    .Call('_DualSimplex_cosine_similarity', PACKAGE = 'DualSimplex', a, b)
}

#' Get cosine distance between columns
#'
#' @param X input matrix
#' @return derivative for X
cosine_between_rows <- function(X) {
    .Call('_DualSimplex_cosine_between_rows', PACKAGE = 'DualSimplex', X)
}

#' Get low rank approximation with SVD method.
#'
#' @param X inpit matrix.
#' @param rank desired approximation rank.
#' @param iterations number of iterations to perform.
#' @param left elements cropped (should be zero).
#' @param right elements cropped (infinity by default)
#' @return named list containing new matrix, frobenious history for negative elements and number of negative elements.
#' @export
getNonnegativeLowRankApproximationWithSVD <- function(X, rank, iterations, left = 0, right = -1) {
    .Call('_DualSimplex_getNonnegativeLowRankApproximationWithSVD', PACKAGE = 'DualSimplex', X, rank, iterations, left, right)
}

#' Get low rank approximation with SVD method.
#'
#' @param X inpit matrix.
#' @param rank desired approximation rank.
#' @param p number of randomizations.
#' @param k number of randomized columns.
#' @param iterations number of iterations to perform.
#' @param left elements cropped (should be zero).
#' @param right elements cropped (infinity by default)
#' @return named list containing new matrix, frobenious history for negative elements and number of negative elements.
#' @export
getNonnegativeLowRankApproximationWithHMT <- function(X, rank, p, k, iterations, left = 0, right = -1) {
    .Call('_DualSimplex_getNonnegativeLowRankApproximationWithHMT', PACKAGE = 'DualSimplex', X, rank, p, k, iterations, left, right)
}

#' Get low rank approximation with GN method.
#'
#' @param X inpit matrix
#' @param rank desired approximation rank
#' @param l parameter for Psi
#' @param iterations number of iterations to perform
#' @param left elements cropped (should be zero)
#' @param right elements cropped (infinity by default)
#' @return named list containing new matrix, frobenious history for negative elements and number of negative elements.
#' @export
getNonnegativeLowRankApproximationWithGN <- function(X, rank, l, iterations, left = 0, right = -1) {
    .Call('_DualSimplex_getNonnegativeLowRankApproximationWithGN', PACKAGE = 'DualSimplex', X, rank, l, iterations, left, right)
}

#' Get low rank approximation with Tangent method.
#'
#' @param X inpit matrix.
#' @param rank desired approximation rank.
#' @param iterations number of iterations to perform.
#' @param left elements cropped (should be zero).
#' @param right elements cropped (infinity by default)
#' @return named list containing new matrix, frobenious history for negative elements and number of negative elements.
#' @export
getNonnegativeLowRankApproximationWithTangentMethod <- function(X, rank, iterations, left = 0, right = -1) {
    .Call('_DualSimplex_getNonnegativeLowRankApproximationWithTangentMethod', PACKAGE = 'DualSimplex', X, rank, iterations, left, right)
}

#' Get nnls solution
#'
#' @param A matrix A
#' @param b coefficients
#' @param max_iter max number of iterations
#' @param tol precision
#' @return derivative for X
#' @export
nnls_C__ <- function(A, b, max_iter = 500L, tol = 1e-6) {
    .Call('_DualSimplex_nnls_C__', PACKAGE = 'DualSimplex', A, b, max_iter, tol)
}

#' Get nnls solution
#'
#' @param A matrix A
#' @param b coefficients
#' @param max_iter max number of iterations
#' @param tol precision
#' @return derivative for X
#' @export
nnls_nonzero_C__ <- function(A, b, max_iter = 500L, tol = 1e-6) {
    .Call('_DualSimplex_nnls_nonzero_C__', PACKAGE = 'DualSimplex', A, b, max_iter, tol)
}

#' Experimental jump norm calculation. legacy
#'
#' @param X matrix to check
#' @param r_const_X constraint
#' @return matrix
jump_norm <- function(X, r_const_X = 0) {
    .Call('_DualSimplex_jump_norm', PACKAGE = 'DualSimplex', X, r_const_X)
}

#' Experimental: Update X in the direction of new X with predefined threshold
#'
#' @param prev_X previous matrix
#' @param new_X new target matrix
#' @param thresh threshold value
#' @return vector of indicies which passed threshold
update_idx <- function(prev_X, new_X, thresh = 0.8) {
    .Call('_DualSimplex_update_idx', PACKAGE = 'DualSimplex', prev_X, new_X, thresh)
}

#' Hinge loss derivative for proportion matrix (H)
#'
#' @param H result H matrix obtained from X
#' @param R projection vectors R
#' @param precision_ precision to calculate value
#' @return derivative for X
hinge_der_proportions_C__ <- function(H, R, precision_ = 1e-10) {
    .Call('_DualSimplex_hinge_der_proportions_C__', PACKAGE = 'DualSimplex', H, R, precision_)
}

#' Hinge loss derivative for basis matrix (W)
#'
#' @param W result W matrix obtained from Omega
#' @param S projection vectors S
#' @param precision_ precision to calculate value
#' @return derivative for Omega
hinge_der_basis_C__ <- function(W, S, precision_ = 1e-10) {
    .Call('_DualSimplex_hinge_der_basis_C__', PACKAGE = 'DualSimplex', W, S, precision_)
}

#' Hinge function value for input matrix X
#'
#' @param X input matrix
#' @return hinge function value
hinge_C__ <- function(X) {
    .Call('_DualSimplex_hinge_C__', PACKAGE = 'DualSimplex', X)
}

#' Main function to calculate error terms
#'
#' @param X current X
#' @param Omega current Omega
#' @param D_w current D_w
#' @param D_h current D_h
#' @param SVRt current SVRt (Sigma matrix)
#' @param R current R
#' @param S current S
#' @param coef_  # this argument is not used
#' @param coef_der_X learning rate for X
#' @param coef_der_Omega learning rate for Omega
#' @param coef_hinge_H lambda
#' @param coef_hinge_W beta
#' @param coef_pos_D_h experimental coefficient for D_h. legacy. not tested.
#' @param coef_pos_D_w experimental coefficient for D_w.legacy. not tested.
#' @return list with error values
calcErrors <- function(X, Omega, D_w, D_h, SVRt, R, S, coef_, coef_der_X, coef_der_Omega, coef_hinge_H, coef_hinge_W, coef_pos_D_h, coef_pos_D_w) {
    .Call('_DualSimplex_calcErrors', PACKAGE = 'DualSimplex', X, Omega, D_w, D_h, SVRt, R, S, coef_, coef_der_X, coef_der_Omega, coef_hinge_H, coef_hinge_W, coef_pos_D_h, coef_pos_D_w)
}

#' Main function to calculate error terms
#'
#' @param X current X
#' @param Omega current Omega
#' @param D_w current D_w
#' @param SVRt current SVRt (sigma)
#' @param R current R
#' @param S current S
#' @param coef_der_X learning rate X
#' @param coef_der_Omega learning rate Omega
#' @param coef_hinge_H lambda
#' @param coef_hinge_W beta
#' @param coef_pos_D_h experimental coefficient for D. legacy not tested.
#' @param coef_pos_D_w experimental coefficient for D. legacy not tested.
#' @param cell_types number of components (K)
#' @param N current N
#' @param M current M
#' @param iterations number of iterations
#' @param mean_radius_X data dependent restriction for updates
#' @param mean_radius_Omega dependent restriction for updates
#' @param r_const_X experimental. not tested
#' @param r_const_Omega experimental. not tested
#' @param thresh experimental. not tested
#' @return new parameters
derivative_stage2 <- function(X, Omega, D_w, SVRt, R, S, coef_der_X, coef_der_Omega, coef_hinge_H, coef_hinge_W, coef_pos_D_h, coef_pos_D_w, cell_types, N, M, iterations, mean_radius_X, mean_radius_Omega, r_const_X = 0, r_const_Omega = 0, thresh = 0.8) {
    .Call('_DualSimplex_derivative_stage2', PACKAGE = 'DualSimplex', X, Omega, D_w, SVRt, R, S, coef_der_X, coef_der_Omega, coef_hinge_H, coef_hinge_W, coef_pos_D_h, coef_pos_D_w, cell_types, N, M, iterations, mean_radius_X, mean_radius_Omega, r_const_X, r_const_Omega, thresh)
}

#' Main function to calculate error terms
#'
#' @param X current X
#' @param Omega current Omega
#' @param D_w current D_w
#' @param SVRt current SVRt (sigma)
#' @param R current R
#' @param S current S
#' @param coef_der_X learning rate X
#' @param coef_der_Omega learning rate Omega
#' @param coef_hinge_H lambda
#' @param coef_hinge_W beta
#' @param coef_pos_D_h experimental coefficient for D. legacy not tested.
#' @param coef_pos_D_w experimental coefficient for D. legacy not tested.
#' @param cell_types number of components (K)
#' @param N current N
#' @param M current M
#' @param iterations number of iterations
#' @param mean_radius_X data dependent restriction for updates
#' @param mean_radius_Omega dependent restriction for updates
#' @param r_const_X experimental. not tested
#' @param r_const_Omega experimental. not tested
#' @param thresh experimental. not tested
#' @param solution_balancing_threshold experimental. If solution is to far away we re-balance norms of the solution vectors between X and Omega
#' @return new parameters
alternative_derivative_stage2 <- function(X, Omega, D_w, SVRt, R, S, coef_der_X, coef_der_Omega, coef_hinge_H, coef_hinge_W, coef_pos_D_h, coef_pos_D_w, cell_types, N, M, iterations, mean_radius_X, mean_radius_Omega, r_const_X = 0, r_const_Omega = 0, thresh = 0.8, solution_balancing_threshold = 10) {
    .Call('_DualSimplex_alternative_derivative_stage2', PACKAGE = 'DualSimplex', X, Omega, D_w, SVRt, R, S, coef_der_X, coef_der_Omega, coef_hinge_H, coef_hinge_W, coef_pos_D_h, coef_pos_D_w, cell_types, N, M, iterations, mean_radius_X, mean_radius_Omega, r_const_X, r_const_Omega, thresh, solution_balancing_threshold)
}

#' Main function to calculate error terms
#'
#' @param X current X
#' @param Omega current Omega
#' @param D_w current D_w
#' @param SVRt current SVRt (sigma)
#' @param R current R
#' @param S current S
#' @param coef_der_X learning rate X
#' @param coef_der_Omega learning rate Omega
#' @param coef_hinge_H lambda
#' @param coef_hinge_W beta
#' @param coef_pos_D_h experimental coefficient for D. legacy not tested.
#' @param coef_pos_D_w experimental coefficient for D. legacy not tested.
#' @param cell_types number of components (K)
#' @param N current N
#' @param M current M
#' @param iterations number of iterations
#' @param mean_radius_X data dependent restriction for updates
#' @param mean_radius_Omega dependent restriction for updates
#' @param r_const_X experimental. not tested
#' @param r_const_Omega experimental. not tested
#' @param thresh experimental. not tested
#' @param X_center optimization restriction directions for X.
#' @param Omega_center optimization restriction direcitons of Omega.
#' @param theta_threshold angle to restrict optimization/
#' @return new parameters
theta_derivative_stage2 <- function(X, Omega, D_w, SVRt, R, S, X_center, Omega_center, coef_der_X, coef_der_Omega, coef_hinge_H, coef_hinge_W, coef_pos_D_h, coef_pos_D_w, cell_types, N, M, iterations, mean_radius_X, mean_radius_Omega, r_const_X = 0, r_const_Omega = 0, thresh = 0.8, theta_threshold = 0) {
    .Call('_DualSimplex_theta_derivative_stage2', PACKAGE = 'DualSimplex', X, Omega, D_w, SVRt, R, S, X_center, Omega_center, coef_der_X, coef_der_Omega, coef_hinge_H, coef_hinge_W, coef_pos_D_h, coef_pos_D_w, cell_types, N, M, iterations, mean_radius_X, mean_radius_Omega, r_const_X, r_const_Omega, thresh, theta_threshold)
}

#' Reverse Sinkhorn scaling method
#'
#' @param result_H_row H_ss returned by DualSimplex. (row normalized X*R).
#' @param result_W_col W_gs returned by DualSimplex. (row normalized t(S)*Omega).
#' @param D_vs_row row normalizing matrices used for V in forward procedure.
#' @param D_vs_col column normalizing matrices used for V in forward procedure.
#' @param iterations how many iterations back
#' @return named list of W, H, Dv_inv_W_row, H_row, D_ws_col, D_hs_row.
#' @export
reverse_sinkhorn_c <- function(result_H_row, result_W_col, D_vs_row, D_vs_col, iterations) {
    .Call('_DualSimplex_reverse_sinkhorn_c', PACKAGE = 'DualSimplex', result_H_row, result_W_col, D_vs_row, D_vs_col, iterations)
}

#' Forward Sinkhorn scaling method
#'
#' @param V matrix to scale
#' @param iterations W_gs number of iterations.
#' @return named list of V_row, V_col, Dvs_row, Dvs_col
#' @export
sinkhorn_scale_c <- function(V, iterations) {
    .Call('_DualSimplex_sinkhorn_scale_c', PACKAGE = 'DualSimplex', V, iterations)
}

#' More efficient forward Sinkhorn scaling algorithm which check the convergence
#'
#' @param V matrix to scale.
#' @param max_iter Maximum iterations of the Sinkhorn scaling. Default is 20 iterations.
#' @param iter_start_check From which iteration should the function checks the convergence. By default, check started from iteration 5.
#' @param check_every_iter How offeten should we check the convergence. The default is check every 3 iterations.
#' @param epsilon The tolerance for convergece. Default value is 1.490116e-08, which is similar to R's built in `all.equal` function.
#' @return named list of V_row, V_col, D_row, D_col, iterations.
#' @export
efficient_sinkhorn <- function(V, max_iter = 20L, iter_start_check = 5L, check_every_iter = 3L, epsilon = 1.490116e-08) {
    .Call('_DualSimplex_efficient_sinkhorn', PACKAGE = 'DualSimplex', V, max_iter, iter_start_check, check_every_iter, epsilon)
}

#' Extended version of sinkhorn transformation, returning all matrices produced. (time/memory consuming)
#' Matrices include V_ss, W_ss, H_ss, V_gs, W_gs, H_gs, D_v_col, D_v_row, D_h_row, D_h_col
#'
#' @param V matrix to scale. (V=WH)
#' @param W matrix to scale.
#' @param H matrix to scale.
#' @param n_iter exact number of iterations
#' @export
extended_sinkhorn <- function(V, W, H, n_iter) {
    .Call('_DualSimplex_extended_sinkhorn', PACKAGE = 'DualSimplex', V, W, H, n_iter)
}

#' Helper function to perfrom iteration scaling
#'
#' @param V matrix to scale.
#' @param D_vs_row matrix stroing row scaling at each iteration  
#' @param D_vs_col matrix stroing column scaling at each iteration
#' @param iter iteration at which Sinkhorn is converged
#' @param do_last_step whether to perform  very last normalization
#' @return scaled matrix
#' @export
sinkhorn_sweep_c <- function(V, D_vs_row, D_vs_col, iter, do_last_step) {
    .Call('_DualSimplex_sinkhorn_sweep_c', PACKAGE = 'DualSimplex', V, D_vs_row, D_vs_col, iter, do_last_step)
}

