# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Main function to calculate error terms
#'
#' @param X current X
#' @param Omega current Omega
#' @param D_w current D_w
#' @param SVRt current SVRt (sigma)
#' @param R current R
#' @param S current S
#' @param coef_der_X learning rate X
#' @param coef_der_Omega learning rate Omega
#' @param coef_hinge_H lambda
#' @param coef_hinge_W beta
#' @param coef_pos_D_h experimental coefficient for D. legacy not tested.
#' @param coef_pos_D_w experimental coefficient for D. legacy not tested.
#' @param cell_types number of components (K)
#' @param N current N
#' @param M current M
#' @param iterations number of iterations
#' @param mean_radius_X data dependent restriction for updates
#' @param mean_radius_Omega dependent restriction for updates
#' @param r_const_X experimental. not tested
#' @param r_const_Omega experimental. not tested
#' @param thresh experimental. not tested
#' @return new parameters
alternative_derivative_stage2 <- function(X, Omega, D_w, SVRt, R, S, coef_der_X, coef_der_Omega, coef_hinge_H, coef_hinge_W, coef_pos_D_h, coef_pos_D_w, cell_types, N, M, iterations, mean_radius_X, mean_radius_Omega, r_const_X = 0, r_const_Omega = 0, thresh = 0.8) {
    .Call('_DualSimplex_alternative_derivative_stage2', PACKAGE = 'DualSimplex', X, Omega, D_w, SVRt, R, S, coef_der_X, coef_der_Omega, coef_hinge_H, coef_hinge_W, coef_pos_D_h, coef_pos_D_w, cell_types, N, M, iterations, mean_radius_X, mean_radius_Omega, r_const_X, r_const_Omega, thresh)
}

#' Get cosine distance between columns
#'
#' @param X input matrix
#' @return derivative for X
find_cosine <- function(X) {
    .Call('_DualSimplex_find_cosine', PACKAGE = 'DualSimplex', X)
}

#' Get low rank approximation with SVD method.
#'
#' @param X inpit matrix.
#' @param rank desired approximation rank.
#' @param iterations number of iterations to perform.
#' @param left elements cropped (should be zero).
#' @param right elements cropped (infinity by default)
#' @return named list containing new matrix, frobenious history for negative elements and number of negative elements.
#' @export
getNonnegativeLowRankApproximationWithSVD <- function(X, rank, iterations, left = 0, right = -1) {
    .Call('_DualSimplex_getNonnegativeLowRankApproximationWithSVD', PACKAGE = 'DualSimplex', X, rank, iterations, left, right)
}

#' Get low rank approximation with SVD method.
#'
#' @param X inpit matrix.
#' @param rank desired approximation rank.
#' @param p number of randomizations.
#' @param k number of randomized columns.
#' @param iterations number of iterations to perform.
#' @param left elements cropped (should be zero).
#' @param right elements cropped (infinity by default)
#' @return named list containing new matrix, frobenious history for negative elements and number of negative elements.
#' @export
getNonnegativeLowRankApproximationWithHMT <- function(X, rank, p, k, iterations, left = 0, right = -1) {
    .Call('_DualSimplex_getNonnegativeLowRankApproximationWithHMT', PACKAGE = 'DualSimplex', X, rank, p, k, iterations, left, right)
}

#' Get low rank approximation with GN method.
#'
#' @param X inpit matrix
#' @param rank desired approximation rank
#' @param l parameter for Psi
#' @param iterations number of iterations to perform
#' @param left elements cropped (should be zero)
#' @param right elements cropped (infinity by default)
#' @return named list containing new matrix, frobenious history for negative elements and number of negative elements.
#' @export
getNonnegativeLowRankApproximationWithGN <- function(X, rank, l, iterations, left = 0, right = -1) {
    .Call('_DualSimplex_getNonnegativeLowRankApproximationWithGN', PACKAGE = 'DualSimplex', X, rank, l, iterations, left, right)
}

#' Get low rank approximation with Tangent method.
#'
#' @param X inpit matrix.
#' @param rank desired approximation rank.
#' @param iterations number of iterations to perform.
#' @param left elements cropped (should be zero).
#' @param right elements cropped (infinity by default)
#' @return named list containing new matrix, frobenious history for negative elements and number of negative elements.
#' @export
getNonnegativeLowRankApproximationWithTangentMethod <- function(X, rank, iterations, left = 0, right = -1) {
    .Call('_DualSimplex_getNonnegativeLowRankApproximationWithTangentMethod', PACKAGE = 'DualSimplex', X, rank, iterations, left, right)
}

#' Get nnls solution
#'
#' @param A matrix A
#' @param b coefficients
#' @param max_iter max number of iterations
#' @param tol precision
#' @return derivative for X
#' @export
nnls_C__ <- function(A, b, max_iter = 500L, tol = 1e-6) {
    .Call('_DualSimplex_nnls_C__', PACKAGE = 'DualSimplex', A, b, max_iter, tol)
}

#' Experimental jump norm calculation. legacy
#'
#' @param X matrix to check
#' @param r_const_X constraint
#' @return matrix
jump_norm <- function(X, r_const_X = 0) {
    .Call('_DualSimplex_jump_norm', PACKAGE = 'DualSimplex', X, r_const_X)
}

#' Experimental: Update X in the direction of new X with predefined threshold
#'
#' @param prev_X previous matrix
#' @param new_X new target matrix
#' @param thresh threshold value
#' @return vector of indicies which passed threshold
update_idx <- function(prev_X, new_X, thresh = 0.8) {
    .Call('_DualSimplex_update_idx', PACKAGE = 'DualSimplex', prev_X, new_X, thresh)
}

#' Hinge loss derivative for proportion matrix (H)
#'
#' @param H result H matrix obtained from X
#' @param R projection vectors R
#' @param precision_ precision to calculate value
#' @return derivative for X
hinge_der_proportions_C__ <- function(H, R, precision_ = 1e-10) {
    .Call('_DualSimplex_hinge_der_proportions_C__', PACKAGE = 'DualSimplex', H, R, precision_)
}

#' Hinge loss derivative for basis matrix (W)
#'
#' @param W result W matrix obtained from Omega
#' @param S projection vectors S
#' @param precision_ precision to calculate value
#' @return derivative for Omega
hinge_der_basis_C__ <- function(W, S, precision_ = 1e-10) {
    .Call('_DualSimplex_hinge_der_basis_C__', PACKAGE = 'DualSimplex', W, S, precision_)
}

#' Hinge function value for input matrix X
#'
#' @param X input matrix
#' @return hinge function value
hinge_C__ <- function(X) {
    .Call('_DualSimplex_hinge_C__', PACKAGE = 'DualSimplex', X)
}

#' Main function to calculate error terms
#'
#' @param X current X
#' @param Omega current Omega
#' @param D_w current D_w
#' @param D_h current D_h
#' @param SVRt current SVRt (Sigma matrix)
#' @param R current R
#' @param S current S
#' @param coef_  # this argument is not used
#' @param coef_der_X learning rate for X
#' @param coef_der_Omega learning rate for Omega
#' @param coef_hinge_H lambda
#' @param coef_hinge_W beta
#' @param coef_pos_D_h experimental coefficient for D_h. legacy. not tested.
#' @param coef_pos_D_w experimental coefficient for D_w.legacy. not tested.
#' @return list with error values
calcErrors <- function(X, Omega, D_w, D_h, SVRt, R, S, coef_, coef_der_X, coef_der_Omega, coef_hinge_H, coef_hinge_W, coef_pos_D_h, coef_pos_D_w) {
    .Call('_DualSimplex_calcErrors', PACKAGE = 'DualSimplex', X, Omega, D_w, D_h, SVRt, R, S, coef_, coef_der_X, coef_der_Omega, coef_hinge_H, coef_hinge_W, coef_pos_D_h, coef_pos_D_w)
}

#' Main function to calculate error terms
#'
#' @param X current X
#' @param Omega current Omega
#' @param D_w current D_w
#' @param SVRt current SVRt (sigma)
#' @param R current R
#' @param S current S
#' @param coef_der_X learning rate X
#' @param coef_der_Omega learning rate Omega
#' @param coef_hinge_H lambda
#' @param coef_hinge_W beta
#' @param coef_pos_D_h experimental coefficient for D. legacy not tested.
#' @param coef_pos_D_w experimental coefficient for D. legacy not tested.
#' @param cell_types number of components (K)
#' @param N current N
#' @param M current M
#' @param iterations number of iterations
#' @param mean_radius_X data dependent restriction for updates
#' @param mean_radius_Omega dependent restriction for updates
#' @param r_const_X experimental. not tested
#' @param r_const_Omega experimental. not tested
#' @param thresh experimental. not tested
#' @return new parameters
derivative_stage2 <- function(X, Omega, D_w, SVRt, R, S, coef_der_X, coef_der_Omega, coef_hinge_H, coef_hinge_W, coef_pos_D_h, coef_pos_D_w, cell_types, N, M, iterations, mean_radius_X, mean_radius_Omega, r_const_X = 0, r_const_Omega = 0, thresh = 0.8) {
    .Call('_DualSimplex_derivative_stage2', PACKAGE = 'DualSimplex', X, Omega, D_w, SVRt, R, S, coef_der_X, coef_der_Omega, coef_hinge_H, coef_hinge_W, coef_pos_D_h, coef_pos_D_w, cell_types, N, M, iterations, mean_radius_X, mean_radius_Omega, r_const_X, r_const_Omega, thresh)
}

#' Reverse Sinkhorn scaling method
#'
#' @param result_H_row H_ss returned by DualSimplex. (row normalized X*R).
#' @param result_W_col W_gs returned by DualSimplex. (row normalized t(S)*Omega).
#' @param D_vs_row row normalizing matrices used for V in forward procedure.
#' @param D_vs_col column normalizing matrices used for V in forward procedure.
#' @param iterations how many iterations back
#' @return named list of W, H, Dv_inv_W_row, H_row, D_ws_col, D_hs_row.
#' @export
reverse_sinkhorn_c <- function(result_H_row, result_W_col, D_vs_row, D_vs_col, iterations) {
    .Call('_DualSimplex_reverse_sinkhorn_c', PACKAGE = 'DualSimplex', result_H_row, result_W_col, D_vs_row, D_vs_col, iterations)
}

#' Forward Sinkhorn scaling method
#'
#' @param V matrix to scale
#' @param iterations W_gs number of iterations.
#' @return named list of V_row, V_col, Dvs_row, Dvs_col
#' @export
sinkhorn_scale_c <- function(V, iterations) {
    .Call('_DualSimplex_sinkhorn_scale_c', PACKAGE = 'DualSimplex', V, iterations)
}

#' Main function to calculate error terms
#'
#' @param X current X
#' @param Omega current Omega
#' @param D_w current D_w
#' @param SVRt current SVRt (sigma)
#' @param R current R
#' @param S current S
#' @param coef_der_X learning rate X
#' @param coef_der_Omega learning rate Omega
#' @param coef_hinge_H lambda
#' @param coef_hinge_W beta
#' @param coef_pos_D_h experimental coefficient for D. legacy not tested.
#' @param coef_pos_D_w experimental coefficient for D. legacy not tested.
#' @param cell_types number of components (K)
#' @param N current N
#' @param M current M
#' @param iterations number of iterations
#' @param mean_radius_X data dependent restriction for updates
#' @param mean_radius_Omega dependent restriction for updates
#' @param r_const_X experimental. not tested
#' @param r_const_Omega experimental. not tested
#' @param thresh experimental. not tested
#' @return new parameters
symmetric_derivative_stage2 <- function(X, Omega, D_w, SVRt, R, S, coef_der_X, coef_der_Omega, coef_hinge_H, coef_hinge_W, coef_pos_D_h, coef_pos_D_w, cell_types, N, M, iterations, mean_radius_X, mean_radius_Omega, r_const_X = 0, r_const_Omega = 0, thresh = 0.8) {
    .Call('_DualSimplex_symmetric_derivative_stage2', PACKAGE = 'DualSimplex', X, Omega, D_w, SVRt, R, S, coef_der_X, coef_der_Omega, coef_hinge_H, coef_hinge_W, coef_pos_D_h, coef_pos_D_w, cell_types, N, M, iterations, mean_radius_X, mean_radius_Omega, r_const_X, r_const_Omega, thresh)
}

